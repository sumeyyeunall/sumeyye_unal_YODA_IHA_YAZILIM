
## ROS TEMEL KAVRAMLARI

### ROS Nedir?
ROS (Robot Operating System), robot yazılımı geliştirmek için kullanılan açık kaynaklı bir yazılım çatısıdır (framework). İsmi işletim sistemi gibi görünse de aslında tek başına bir işletim sistemi değildir. Linux (çoğunlukla Ubuntu) üzerinde çalışan ve robot uygulamaları geliştirmeyi kolaylaştıran bir ara katman (middleware) olarak düşünülebilir.

ROS’un temel amacı, robot yazılımı geliştirirken sıkça karşılaşılan problemleri çözmek ve geliştiricilere hazır bir altyapı sunmaktır. Örneğin:


Sensör verilerinin alınması


Motorların kontrol edilmesi


Farklı yazılım modüllerinin birbiriyle haberleşmesi


Simülasyon ve gerçek robot üzerinde aynı kodun çalıştırılabilmesi


gibi işlemler bu sayede daha modüler bir şekilde yapılabilir. 


Kısaca robotik sistemlerin karmaşık yapısını(kamera, lidar, IMU, motor sürücüleri) bağımsız modüller halinde çalıştırmaya imkan tanır.


### Nasıl Çalışır?


Robotun algılama, kontrol ve karar verme gibi görevleri bağımsız nodelar halinde yürütülür ve bu nodelar topic, service, action ve parameter mekanizmaları üzerinden birbiriyle haberleşir. Bu iletişim sayesinde sensörlerden gelen veriler işlenir, kararlar üretilir ve motorlara komutlar gönderilir.


### Temel Bileşenleri ve Etkileşimleri 


#### Node 

Node, ROS 2’de çalışan en küçük yürütülebilir programdır.Her node genellikle tek bir sorumluluk üstlenir. Bu yapı sayesinde sistem monolitik (tek parça) olmak yerine modüler olur. Yani bir node çökerse tüm sistem durmaz.


Örnek node görevleri:


Kameradan görüntü almak


Lidar verisini işlemek


Motorlara hız komutu göndermek


Robotun konumunu hesaplamak

```
#calisan nodeları listelemek için :
ros2 node list

#belirli bir nodeun detaylarını görmek için:

ros2 node info /node_adi

```


#### Topic 


Topic, node’lar arasında sürekli veri akışı sağlayan haberleşme kanalıdır.ROS 2de en sık kullanılan iletişim yöntemidir. Data akışı yani streaming içindir.Birden çok node aynı topic’i dinleyebilir veya yayınlayabilir.Genellikle sensör verileri gibi sürekli akan bilgiler için kullanılır. Örneğin:

/scan → Lidar verisi yayınlanır

/camera/image → Kamera görüntüsü yayınlanır

/turtle1/cmd_vel → Robotun hız bilgisi(Twist mesajı) gönderilir



```
#topicleri görmek içn:

$ ros2 topic list


$ ros2 topic info /cmd_vel


#belirli bir topicden gelen verileri canli dinlemek/izlemek için:

$ ros2 topic echo /topic_adi
```

#### Publisher ve Subscriber

Publisher: bir nodeun bir topice veri gönderen tarafıdır. Örn Motor kontrol nodeu /cmd_vel topicine hız bilgisi yayınlar.


Subscriber: bir topici dinleyen nodedur.Publisher’ın gönderdiği veriyi alır ve kullanır. Örn robot gövde nodeu /cmd_vel topicini dinleyerek motorları hareket ettirir.



Bir topicte birden fazla publisher olabilir. Bir topici birden fazla subscriber dinleyebilir. Nodelar birbirini tanımak zorunda değildir. Sistemin loosely coupled olmasını sağlar. 


#### Service 

nodelar arasında request–response mantığıyla çalışan bir haberleşme yöntemidir. Topiclerden farklı olarak serviceler sürekli veri akışı sağlamaz yalnızca bir node başka bir node’a özel bir istekte bulunduğunda çalışır ve tek seferlik bir cevap döner. Bu yapı, robot sistemlerinde “şimdi yap”, “bilgi ver”, “resetle” gibi anlık ve kontrollü işlemler için kullanılır.

```
ros2 service list

#servis türünü öğrenme:

ros2 service type /spawn


#servis arayüzünü inceleme:

ros2 interface show turtlesim/srv/Spawn


 #servis çağırma:

ros2 service call /clear std_srvs/srv/Empty


#argümanlı servis çağırma:

ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"


```

#### Action 


Action uzun süren işlemler için kullanılan iletişim yöntemidir. SErvicten farkı, işlem uzun sürebilir, süreç boyunca feedback alınır, işlem iptal edilebilir. Yani action, hem service’in kısa cevaplı yapısını hem de topic’in sürekli bilgi akışını birleştirir. Robotun uzun süre görev yapan davranışlarını kontrol etmek için idealdir (örneğin bir hedefe gitme, yol planlama vb).

```
#action tiplerinin detaylarını görmek için:
ros2 interface show turtlesim/action/RotateAbsolute
```

Goal→ Actiona gönderilecek istek verileri

Result→ Action tamamlandığında dönen veriler

Feedback→ Action çalışırken gönderilen durumda bilgiler

Örneğin RotateAbsolute actionı:
```
float64 theta #theta ile hedef dönüş açısı verilir
---
float64 delta #işlem sonunda delta sonucu elde edilir
---
float32 feedback #süreç boyunca tanımlı feedback dönülür
```

#### Parameter 


Kısaca nodeların davranışını ayarlar. Her node kendi parametrelerini taşır ve çalışırken bu değerler okunabilir veya değiştirilebilir.

```
#listing parameters

ros2 param list


ros2 param get /turtlesim background_r #turtlesim düğümünün background_r parametresinin şu anki değerini verir

#bir paramtereyi değiştir :
ros2 param set /node_adi param_adi yeni_deger

```

#### launch dosyaları 

Birden fazla nodeu aynı anda başlatmak ve parametreleri yönetmek için kullanılır.

```
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='my_turtle',
            parameters=[{'background_r': 100, 'background_g': 150, 'background_b': 200}]
        )
    ])

```
### ROS1 VE ROS2 arasındaki temel farklar 


#### Haberleşme Altyapısı(Middleware)

ROS1: Kendi haberleşme protokolünü (TCPROS/UDPROS) kullanıyor. Bu yüzden bir roscore (master node) olması şart. Eğer master çökerse bütün sistem gidiyor.

ROS2: Endüstri standardı olan DDS (Data Distribution Service) üzerine kurulu. En büyük fark burada; artık bir "master" node yok. Node'lar birbirini ağ üzerinden otomatik bulabiliyor (discovery). Bu da sistemi çok daha güvenilir yapıyor.

#### İşletim Sistemi ve Dil Desteği

ROS1: Resmen sadece Linux (özellikle Ubuntu) üzerinde tam performans çalışıyor. Python 2 desteğiyle başladı ama artık ömrünü tamamlıyor.


ROS2: "Cross-platform" yani Windows 10, macOS ve Ubuntu üzerinde doğrudan çalışabiliyor. Ayrıca tamamen Python 3 ve modern C++ (C++14/17) standartlarını kullanıyor.


#### Gerçek Zamanlı(Real-Time) Çalışma

ROS1: Gerçek zamanlı sistemler için tasarlanmamış. Gecikmeler (latency) belirsiz olabiliyor.


ROS2: DDS sayesinde Real-Time desteği var. Endüstriyel robotlar veya hızlı tepki vermesi gereken otonom araçlar için bu özellik hayat kurtarıyor.

#### Düğüm (Node) ve Yaşam Döngüsü (Lifecycle)

ROS1: Bir node'u başlattığında kontrol pek sende değil; ya çalışıyordur ya da kapalıdır.


ROS2: Managed Nodes (Lifecycle Nodes) kavramı geldi. Bir node'un ne zaman yapılandırılacağını, ne zaman aktifleşeceğini veya duraklatılacağını kod üzerinden yönetebiliyorsun.

#### Birden Fazla Robot (Multi-Robot Support)

ROS1: Aynı ağda birden fazla robot çalıştırmak tam bir işkenceydi (ROS_MASTER_URI ayarları vs.).


ROS2: DDS'in sunduğu "Domain ID" mantığı sayesinde, aynı ağdaki robotları birbirinden ayırmak veya konuşturmak çok daha kolay hale geldi.

#### Güvenlik (Security)

ROS1:Güvenli değil. Ağa bağlanan herkes topic'leri dinleyebilir veya sahte mesaj gönderebilir.


ROS2: SROS (Secure ROS) ile geliyor. Mesajlar şifrelenebiliyor ve kimlik doğrulama yapılabiliyor.


### ROS’un Robotik Projelerinde Yaygın Kullanım Alanları

#### Otonom Mobil Robotlar (AMR) ve Depo Yönetimi

Amazon depolarında gezen robotların çoğunun arkasında ROS var. Robotun bir noktadan diğerine çarpmadan gitmesini sağlayan o meşhur Nav2 (Navigation 2) kütüphanesi bu işin kalbi.  

- **Ne yapıyor?** Haritalama (SLAM), yol planlama ve engellerden kaçınma.  
- **Nerede kullanılır?** Fabrika içi taşıma robotları, hastane servis robotları.  

#### Robotik Kollar ve Manipülatörler (MoveIt!)

Endüstriyel robot kollarının "şu parçayı al, şuraya koy" derken yaptığı o karmaşık ters kinematik (inverse kinematics) hesaplamaları için ROS içindeki MoveIt! kütüphanesi kullanılıyor.  

- **Ne yapıyor?** Çarpışma kontrolü, eklem yörüngesi oluşturma ve 3D algılama.  
- **Nerede kullanılır?** Montaj hatları, cerrahi robotlar, paketleme sistemleri.  

#### Otonom Sürüş ve Sürücüsüz Araçlar

Otonom araçların sensör füzyonu (Lidar, Kamera, Radar verilerini birleştirme) aşamasında ROS harika bir orkestra şefi görevi görüyor. Özellikle Autoware gibi açık kaynaklı otonom sürüş yazılımları tamamen ROS tabanlıdır.  

- **Ne yapıyor?** Nesne tespiti, şerit takibi ve trafik levhası tanıma.  
- **Nerede kullanılır?** Sürücüsüz taksiler, otonom teslimat araçları.  

#### İnsansız Hava Araçları (İHA/Drone)

Özellikle sürü (swarm) droneların birbiriyle haberleşmesi ve GPS olmayan kapalı alanlarda konumlarını bulmaları için ROS (genellikle PX4 veya ArduPilot ile entegre) tercih ediliyor.  

- **Ne yapıyor?** Stabilizasyon, sürü yönetimi ve otonom iniş-kalkış.  
- **Nerede kullanılır?** Arama kurtarma droneları, tarımsal ilaçlama sistemleri.  

#### Simülasyon ve Dijital İkizler (Gazebo)

Gerçek robotu kırmadan önce her şeyi sanal dünyada denemek zorundayız. ROS'un Gazebo simülasyonu ile entegre çalışması, fiziksel bir robota sahip olmadan bile proje geliştirmeyi sağlıyor.  

- **Ne yapıyor?** Gerçek dünya fizik kurallarını (yerçekimi, sürtünme) simüle ediyor.  
- **Nerede kullanılır?** Robotik eğitimleri, prototip testleri.  

### ROS’un İnsansız Hava Aracı (İHA) Projelerindeki Rolü


İHA projelerinde otonom uçuş, görev planlama ve sensör entegrasyonu açısından merkezi bir rol oynar. Dronelarda kullanılan GPS, IMU, barometre, kamera ve Lidar gibi sensörlerden gelen veriler, ROS node’ları tarafından işlenir ve uçuş kontrol algoritmalarına aktarılır.bu sayede droneun konumu, hızı ve yönelimi sürekli takip edilir.

ROS, İHAların uçuş kontrol yazılımları ile entegrasyonu için de kullanılır. Örneğin PX4 veya ArduPilot gibi otopilot sistemleri ROS ile haberleşerek yüksek seviyeli görevlerin(hedefe gitme, belirli noktada durma, alan tarama vb.) gerçekleştirilmesini sağlar. Bu noktada ROS’un topic, service ve action yapıları devreye girer.

ROS, görüntü işleme ve yapay zeka tabanlı İHA uygulamalarında da yaygın şekilde kullanılır. Kamera verileri ROS üzerinden OpenCV, TensorFlow veya PyTorch ile işlenerek hedef tespiti, nesne takibi veya otonom iniş gibi gelişmiş yetenekler kazandırılabilir.

Ayrıca ROS ile simülasyon ortamlarında (Gazebo, Webots) İHA algoritmaları test edilebilir. Bu sayede gerçek dronelara geçmeden önce: Otonom uçuş algoritmaları, engel algılama ve kaçınma, sensör veri akışı gibi tüm kritik işlevler güvenli şekilde denenebilir.



----

###Workspace oluşturma

```
#Klasör yapısını oluşturma
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src

```
###Paket oluşturma 

ROS 2'de her uygulama bir paket içerisinde yer alır. Python tabanlı bir paket oluşturmak için: rosidl_default_generators ve rclpy.

```
ros2 pkg create --build-type ament_python --license Apache-2.0 <paket_adi>
```
###Basit Bir Publisher

Bir node oluşturup belirli bir topice veri göndermek için şu adımlar izlenirlen adımlar:
```
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class basic_publisher(Node):
    def __init__(self):
        super().__init__('basic_publisher')
        #'topic' isimli kanala mesaj gönderen bir publisher
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5 
        self.timer = self.create_timer(timer_period, self.timer_callback)
    def timer_callback(self):
        msg = String()
        msg.data = 'Merhaba ROS 2!'
        self.publisher_.publish(msg)
        self.get_logger().info('yayinlaniyor!: "%s"' % msg.data)
        
def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = basic_publisher()
    rclpy.spin(basic_publisher)
    basic_publisher.destroy_node()
    rclpy.shutdown()
```
###Basit Bir Publisher
Yayınlanan veriyi dinlemek için kullanılan yapıdır.

```
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class basic_subscriber(Node):
    def __init__(self):
        super().__init__('basic_subscriber')
        #'topic' kanalını dinler ve her mesaj geldiğinde listener_callback'i çağırır
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
    def listener_callback(self, msg):
        self.get_logger().info('Alınan Veri: "%s"' % msg.data)
```

###Derleme ve çalıştırma

Python kodlarımızı yazdıktan sonra sistemin bunları tanıması için derlememiz ve environment değişkenlerini ayarlamamız gerekir.

```
cd ~/ros2_ws
colcon build --packages-select <paket_adi>
```

```
source install/setup.bash #her yeni terminal açıldığında yapılmalıdır
```
```
ros2 run <paket_adi> <executable_adi>

```

### Bağımlılıkları Kontrol Etme

Bir paketi derlemeden önce eksik kütüphane olup olmadığını kontrol etmek için rosdep kullanılır
```
rosdep install -i --from-path src --rosdistro humble -y
```

### Service & Client 
Düğümler servis kullanarak haberleştiğinde, veriyi talep eden düğüme Client (İstemci), bu talebe yanıt veren düğüme ise Service (Servis) düğümü denir. Bu yapı "istek-yanıt" (request-response) mantığına dayanır. Buradaki servis düğümü, gelen iki sayıyı toplar ve sonucu döner.
```
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class SimpleService(Node):
    def __init__(self):
        super().__init__('simple_service')
        #Servis tipi, servis adı ve callback fonksiyonu tanımlanır
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b  #yoplama işlemi
        self.get_logger().info('Gelen İstek\na: %d b: %d' % (request.a, request.b))
        return response
```
Client terminalden aldığı argümanları servise gönderir ve sonucu bekler.
```
import sys
from example_interfaces.srv import AddTwoInts
import rclpy
from rclpy.node import Node

class SimpleClientAsync(Node):
    def __init__(self):
        super().__init__('simple_client_async')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        #servis aktif olana kadar saniyede bir kontrol eder
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Servis bekleniyor...')
        self.req = AddTwoInts.Request()
    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        return self.cli.call_async(self.req) #asenkron çağrı
```

**not**: setup.py dosyasına entry pointlerini eklemeliyiz:
```
'service = py_srvcli.service_member_function:main',
'client = py_srvcli.client_member_function:main',

```

###Custom Interfaces 

Standart kütüphaneler (örneğin std_msgs) her zaman projemizin ihtiyaçlarını karşılamayabilir. Bu durumda kendi mesaj (.msg), servis (.srv) ve aksiyon (.action) tiplerimizi tanımlarız.

Örn. ilgili verileri (bir sensörün X, Y, Z koordinatları gibi) tek bir paket halinde göndermek için.


```
#arayüz paketi
ros2 pkg create --build-type ament_cmake tutorial_interfaces
```
Paket içinde msg ve srv adında iki klasör oluşturulur:


Örn:
msg/Num.msg: Sadece bir veri tipi içerir. 
```
int64 num
```
srv/AddThreeInts.srv: Üç sayıyı toplayıp bir yanıt dönen yapı.
```
int64 a
int64 b
int64 c
---
int64 sum

```
Bu dosyaların sisteme tanıtılması ve Python/C++ dillerine çevrilmesi için bazı eklemeler yapılması gerekir. 


package.xml içine eklenecekler:

```
<build_tool_dependency>rosidl_default_generators</build_tool_dependency>

<exec_dependency>rosidl_default_runtime</exec_dependency>

<member_of_group>rosidl_interface_packages</member_of_group>
```
derleme: 
```
colcon build --packages-select tutorial_interfaces

```






