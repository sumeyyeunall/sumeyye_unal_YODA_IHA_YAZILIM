
## ROS TEMEL KAVRAMLARI

### ROS Nedir?
ROS (Robot Operating System), robot yazılımı geliştirmek için kullanılan açık kaynaklı bir yazılım çatısıdır (framework). İsmi işletim sistemi gibi görünse de aslında tek başına bir işletim sistemi değildir. Linux (çoğunlukla Ubuntu) üzerinde çalışan ve robot uygulamaları geliştirmeyi kolaylaştıran bir ara katman (middleware) olarak düşünülebilir.

ROS’un temel amacı, robot yazılımı geliştirirken sıkça karşılaşılan problemleri çözmek ve geliştiricilere hazır bir altyapı sunmaktır. Örneğin:


Sensör verilerinin alınması


Motorların kontrol edilmesi


Farklı yazılım modüllerinin birbiriyle haberleşmesi


Simülasyon ve gerçek robot üzerinde aynı kodun çalıştırılabilmesi


gibi işlemler bu sayede daha modüler bir şekilde yapılabilir. 


Kısaca robotik sistemlerin karmaşık yapısını(kamera, lidar, IMU, motor sürücüleri) bağımsız modüller halinde çalıştırmaya imkan tanır.


### Nasıl Çalışır?


Robotun algılama, kontrol ve karar verme gibi görevleri bağımsız nodelar halinde yürütülür ve bu nodelar topic, service, action ve parameter mekanizmaları üzerinden birbiriyle haberleşir. Bu iletişim sayesinde sensörlerden gelen veriler işlenir, kararlar üretilir ve motorlara komutlar gönderilir.


### Temel Bileşenleri ve Etkileşimleri 


#### Node 

Node, ROS 2’de çalışan en küçük yürütülebilir programdır.Her node genellikle tek bir sorumluluk üstlenir. Bu yapı sayesinde sistem monolitik (tek parça) olmak yerine modüler olur. Yani bir node çökerse tüm sistem durmaz.


Örnek node görevleri:


Kameradan görüntü almak


Lidar verisini işlemek


Motorlara hız komutu göndermek


Robotun konumunu hesaplamak

```
#calisan nodeları listelemek için :
ros2 node list

#belirli bir nodeun detaylarını görmek için:

ros2 node info /node_adi

```


#### Topic 


Topic, node’lar arasında sürekli veri akışı sağlayan haberleşme kanalıdır.ROS 2de en sık kullanılan iletişim yöntemidir. Data akışı yani streaming içindir.Birden çok node aynı topic’i dinleyebilir veya yayınlayabilir.Genellikle sensör verileri gibi sürekli akan bilgiler için kullanılır. Örneğin:

/scan → Lidar verisi yayınlanır

/camera/image → Kamera görüntüsü yayınlanır

/turtle1/cmd_vel → Robotun hız bilgisi(Twist mesajı) gönderilir



```
#topicleri görmek içn:

$ ros2 topic list


$ ros2 topic info /cmd_vel


#belirli bir topicden gelen verileri canli dinlemek/izlemek için:

$ ros2 topic echo /topic_adi
```

#### Publisher ve Subscriber

Publisher: bir nodeun bir topice veri gönderen tarafıdır. Örn Motor kontrol nodeu /cmd_vel topicine hız bilgisi yayınlar.


Subscriber: bir topici dinleyen nodedur.Publisher’ın gönderdiği veriyi alır ve kullanır. Örn robot gövde nodeu /cmd_vel topicini dinleyerek motorları hareket ettirir.



Bir topicte birden fazla publisher olabilir. Bir topici birden fazla subscriber dinleyebilir. Nodelar birbirini tanımak zorunda değildir. Sistemin loosely coupled olmasını sağlar. 


#### Service 

nodelar arasında request–response mantığıyla çalışan bir haberleşme yöntemidir. Topiclerden farklı olarak serviceler sürekli veri akışı sağlamaz yalnızca bir node başka bir node’a özel bir istekte bulunduğunda çalışır ve tek seferlik bir cevap döner. Bu yapı, robot sistemlerinde “şimdi yap”, “bilgi ver”, “resetle” gibi anlık ve kontrollü işlemler için kullanılır.

```
ros2 service list

#servis türünü öğrenme:

ros2 service type /spawn


#servis arayüzünü inceleme:

ros2 interface show turtlesim/srv/Spawn


 #servis çağırma:

ros2 service call /clear std_srvs/srv/Empty


#argümanlı servis çağırma:

ros2 service call /spawn turtlesim/srv/Spawn "{x: 2, y: 2, theta: 0.2, name: ''}"


```

#### Action 


Action uzun süren işlemler için kullanılan iletişim yöntemidir. SErvicten farkı, işlem uzun sürebilir, süreç boyunca feedback alınır, işlem iptal edilebilir. Yani action, hem service’in kısa cevaplı yapısını hem de topic’in sürekli bilgi akışını birleştirir. Robotun uzun süre görev yapan davranışlarını kontrol etmek için idealdir (örneğin bir hedefe gitme, yol planlama vb).

```
#action tiplerinin detaylarını görmek için:
ros2 interface show turtlesim/action/RotateAbsolute
```

Goal→ Actiona gönderilecek istek verileri

Result→ Action tamamlandığında dönen veriler

Feedback→ Action çalışırken gönderilen durumda bilgiler

Örneğin RotateAbsolute actionı:
```
float64 theta #theta ile hedef dönüş açısı verilir
---
float64 delta #işlem sonunda delta sonucu elde edilir
---
float32 feedback #süreç boyunca tanımlı feedback dönülür
```

#### Parameter 


Kısaca nodeların davranışını ayarlar. Her node kendi parametrelerini taşır ve çalışırken bu değerler okunabilir veya değiştirilebilir.

```
#listing parameters

ros2 param list


ros2 param get /turtlesim background_r #turtlesim düğümünün background_r parametresinin şu anki değerini verir

#bir paramtereyi değiştir :
ros2 param set /node_adi param_adi yeni_deger

```

#### launch dosyaları 

Birden fazla nodeu aynı anda başlatmak ve parametreleri yönetmek için kullanılır.

```
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='my_turtle',
            parameters=[{'background_r': 100, 'background_g': 150, 'background_b': 200}]
        )
    ])

```
### ROS1 VE ROS2 arasındaki temel farklar 

ROS1, robotik uygulamalarda uzun yıllardır kullanılan bir çerçevedir ve genellikle tek bir makine üzerinde çalışacak şekilde tasarlanmıştır. ROS1, iletişim için genellikle TCP/IP tabanlı ROS Master’ı kullanır ve gerçek zamanlı sistemlerde sınırlı destek sunar. ROS2 ise bu eksiklikleri gidermek amacıyla geliştirilmiştir; dağıtık sistemleri ve gerçek zamanlı uygulamaları destekler.








### ROS’un Robotik Projelerinde Yaygın Kullanım Alanları

Sensör Verilerinin İşlenmesi

- Lidar, kamera, IMU ve GPS gibi sensörlerden gelen veriler ROS node’ları aracılığıyla toplanır ve işlenir.
- Örnek kullanım:
  - Mobil robotlarda Lidar verisi ile çevre algılama.
  - Kamera verisi ile nesne tanıma.

Haritalama ve Konumlama
- SLAM (Simultaneous Localization and Mapping) algoritmaları ROS ile kolayca entegre edilebilir.
- Robot, bilinmeyen bir ortamda hem kendi konumunu tahmin edebilir hem de ortamın haritasını çıkarabilir.
- Örnek kullanım:
  - Otonom gezgin robotlar
  - Servis ve depo robotları

Hareket Planlama ve Kontrol
- Robot kollarının eklem kontrolü, mobil robotların hız ve yön kontrolü gibi işlemler için güçlü araçlar sunar.
- Örnek kullanım:
  - MoveIt kütüphanesi ile endüstriyel robot kollarının güvenli ve optimize edilmiş hareket planlaması.

Simülasyon ve Test
- Gazebo gibi araçlarla robotlar gerçek donanım olmadan sanal ortamda test edilebilir.
- Avantajlar:
  - Donanımın zarar görmesini önler
  - Algoritmaların erken aşamada test edilmesini sağlar

Çoklu Robot Sistemleri ve İnsan–Robot Etkileşimi
- Birden fazla robotun koordineli çalışması, görev paylaşımı ve merkezi kontrol gibi senaryolar ROS’un mesajlaşma altyapısı ile gerçekleştirilebilir.
- Örnek kullanım:
  - Çoklu robotlu lojistik sistemler
  - İnsan-robot etkileşimli projeler

### ROS’un İnsansız Hava Aracı (İHA) Projelerindeki Rolü


İHA projelerinde otonom uçuş, görev planlama ve sensör entegrasyonu açısından merkezi bir rol oynar. Dronelarda kullanılan GPS, IMU, barometre, kamera ve Lidar gibi sensörlerden gelen veriler, ROS node’ları tarafından işlenir ve uçuş kontrol algoritmalarına aktarılır.bu sayede droneun konumu, hızı ve yönelimi sürekli takip edilir.

ROS, İHAların uçuş kontrol yazılımları ile entegrasyonu için de kullanılır. Örneğin PX4 veya ArduPilot gibi otopilot sistemleri ROS ile haberleşerek yüksek seviyeli görevlerin(hedefe gitme, belirli noktada durma, alan tarama vb.) gerçekleştirilmesini sağlar. Bu noktada ROS’un topic, service ve action yapıları devreye girer.

ROS, görüntü işleme ve yapay zeka tabanlı İHA uygulamalarında da yaygın şekilde kullanılır. Kamera verileri ROS üzerinden OpenCV, TensorFlow veya PyTorch ile işlenerek hedef tespiti, nesne takibi veya otonom iniş gibi gelişmiş yetenekler kazandırılabilir.

Ayrıca ROS ile simülasyon ortamlarında (Gazebo, Webots) İHA algoritmaları test edilebilir. Bu sayede gerçek dronelara geçmeden önce: Otonom uçuş algoritmaları, engel algılama ve kaçınma, sensör veri akışı gibi tüm kritik işlevler güvenli şekilde denenebilir.







